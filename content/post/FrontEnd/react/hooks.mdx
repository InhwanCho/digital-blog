---
title: "React Component 생명주기 및 hooks"
tags:
  - react
  - lifecycle
description: "React 컴포넌트의 라이프사이클에 대해 자세히 알아봅니다."
date: 2024-06-11
---

## 참조

[리엑트 공식문서](https://ko.legacy.reactjs.org/docs/getting-started.html '리엑트공홈')<br/>
[유튜브 별코딩](https://www.youtube.com/watch?v=oqUgcxwrnSY&ab_channel=%EB%B3%84%EC%BD%94%EB%94%A9 '유튜브')

## 컴포넌트 생명주기

React 컴포넌트는 `생성`, `업데이트`, `소멸`의 세 가지 주요 단계로 나뉩니다.

각 단계에서 다양한 라이프사이클 메서드가 호출되며, 이를 통해 컴포넌트의 상태를 관리하고 부가적인 동작을 수행할 수 있습니다.

## Component Lifecycle Phases

React 컴포넌트의 라이프사이클은 다음과 같이 세 단계로 나뉩니다:

1. **Mounting**: 컴포넌트가 DOM에 삽입될 때.
2. **Updating**: 컴포넌트가 리렌더링될 때.
3. **Unmounting**: 컴포넌트가 DOM에서 제거될 때.

단, React 16.8 이후로 함수형 컴포넌트에서도 Hooks를 통해 라이프사이클 메서드와 유사한 기능을 사용할 수 있기때문에
직접 위의 방법을 다루는 함수 `constructor`, `componentDidMount`등은 자주 사용되진 않습니다.

예를들어 **useEffect**는 componentDidMount, componentDidUpdate, componentWillUnmount를 대체합니다.

## React 주요 hooks

### Hooks란?

Hooks는 함수형 컴포넌트에서 상태와 라이프사이클 메서드를 사용할 수 있게 해주는 함수들입니다. 이를 통해 클래스형 컴포넌트의 복잡함을 피하면서도 강력한 기능을 사용할 수 있습니다.

### useState

`useState`는 함수형 컴포넌트에서 `상태를 관리`할 때 사용됩니다. 

상태는 컴포넌트가 재렌더링될 때마다 초기화되지 않으며, 상태 업데이트 함수를 통해 상태를 변경할 수 있습니다.

- useState는 배열을 반환하며, 첫 번째 요소는 상태 값, 두 번째 요소는 상태를 업데이트하는 함수입니다.
- 상태 업데이트 함수는 현재 상태를 인자로 받아 새로운 상태를 반환할 수 있습니다.

```tsx
import React, { useState } from 'react';

const Counter: React.FC = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};

export default Counter;

// 사용 방법
const [count, setCount] = useState(0);

// 상태를 직접 설정
setCount(5);

// 상태를 이전 상태에 기반하여 업데이트
setCount(prevCount => prevCount + 1);
```

### useEffect

useEffect는 `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`를 대체하며, 부수 효과(side effects)를 처리할 때 사용됩니다. 

주로 데이터 페칭, 구독 설정, 수동으로 DOM을 변경하는 작업에 사용됩니다.

```tsx
import React, { useEffect, useState } from 'react';

const Timer: React.FC = () => {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds(seconds => seconds + 1);
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  return <div>{seconds} seconds have passed.</div>;
};

export default Timer;
```

- useEffect는 기본적으로 컴포넌트가 렌더링될 때마다 호출됩니다.
- 두 번째 인자로 전달되는 배열은 의존성 배열(dependency array)로, 이 배열의 값이 변경될 때만 이펙트가 실행됩니다.
- 의존성 배열이 빈 배열일 경우, 이펙트는 컴포넌트가 마운트될 때 한 번만 실행됩니다.
- useEffect는 정리(cleanup) 함수를 반환할 수 있으며, 이는 컴포넌트가 언마운트되기 전에 또는 다음 이펙트가 실행되기 전에 호출됩니다.

```tsx
// 사용 방법 예시
useEffect(() => {
  const handleResize = () => {
    console.log('Window resized');
  };

  window.addEventListener('resize', handleResize);

  return () => {
    window.removeEventListener('resize', handleResize);
  };
}, []); // 빈 배열이므로 마운트와 언마운트 시에만 실행
```

### useRef

useRef는 DOM 요소에 접근하거나, 상태 변경 없이 변수를 저장할 때 사용됩니다. 

useState와 달리, **값이 변경되어도 컴포넌트가 리렌더링되지 않습니다.**


- **DOM 요소 접근**: `useRef`는 컴포넌트가 마운트된 후 특정 DOM 요소에 접근할 수 있도록 도와줍니다. 

예를 들어, 특정 입력 필드에 포커스를 설정하거나, 캔버스 요소에 그리기 작업을 할 때 유용합니다.

- **값 저장**: `useRef`는 컴포넌트가 리렌더링될 때마다 초기화되지 않는 값을 저장하는 데 사용됩니다. 

이전 상태를 추적하거나, 컴포넌트 내에서 전역 변수를 사용하는 것과 비슷하게 동작합니다.


```tsx
import React, { useRef, useEffect } from 'react';

const FocusInput: React.FC = () => {
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    inputRef.current?.focus();
  }, []);

  return <input ref={inputRef} />;
};

export default FocusInput;
```

### useMemo

useMemo는 메모이제이션된 `값`을 반환하며, 성능 최적화를 위해 사용됩니다. 

주로 무거운 계산을 방지하기 위해 사용되며, 마우스 및 드레그 핸들링에 자주 사용됩니다.

```tsx
import React, { useMemo, useState } from 'react';

const ExpensiveComponent: React.FC = () => {
  const [count, setCount] = useState(0);

  const expensiveValue = useMemo(() => {
    console.log('Calculating expensive value...');
    return count * 2;
  }, [count]);

  return (
    <div>
      <p>Expensive value: {expensiveValue}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};

export default ExpensiveComponent;
```

### useCallback

useCallback은 메모이제이션된 콜백 함수를 반환하며, 성능 최적화를 위해 사용됩니다. 

주로 콜백 함수가 자식 컴포넌트에 전달될 때 사용됩니다.

즉, 함수를 저장하여 반복 실행할때 효과적으로 사용할 수 있습니다.

```tsx
const router = useRouter();

const backbtn = useCallback(() => {
  router.back();
}, [router]);
```
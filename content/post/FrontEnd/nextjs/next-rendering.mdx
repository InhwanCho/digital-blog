---
title: "Next.js의 랜더링 과정"
tags:
  - react
  - next.js

description: "Next.js에서의 서버 컴포넌트와 클라이언트 컴포넌트의 렌더링 차이점, 데이터 처리 방식, 최적화된 렌더링 단계별 과정 및 활용 방법을 상세히 설명합니다."
date: 2024-11-06
---

## 컴포넌트란?

React에서 `클라이언트 컴포넌트`는 일반적으로 브라우저에서 실행되는 컴포넌트로, UI 인터랙션과 상태 관리를 다룹니다.

반면, Next.js에서는 `서버 컴포넌트`라는 개념이 추가되어 서버 측에서 미리 렌더링된 결과를 브라우저에 전달할 수 있습니다.

React 컴포넌트는 데이터를 `prop`이나 `state`로 받아와서 JSX를 반환하는 JavaScript 함수입니다.

`클라이언트 컴포넌트`와 달리 `서버 컴포넌트`는 브라우저에서 직접 실행되지 않으므로,

클라이언트에서만 필요한 코드(예: 이벤트 핸들러)를 포함하지 않으며 `서버에서 데이터를 처리하는 데 최적화`되어 있습니다.

`리엑트 클라이언트 컴포넌트` 랜더링와 일반적으로 불리는 컴포넌트 랜더링은 동일한 의미입니다.

이는 `서버 컴포넌트`가 생기게 되며 구분되기위해 클라이언트라는 말을 붙이기도 합니다.

## 컴포넌트 렌더링

React 컴포넌트가 렌더링될 때 JSX는 Babel을 통해 JavaScript 객체인 `React.Element`로 변환됩니다.

이 `React.Element`는 DOM을 표현하는 정보를 담고 있으며, 이를 통해 React는 `Virtual DOM`을 업데이트합니다.

React Element가 확장된 형태가 바로 `Fiber`입니다.

`Fiber`는 React 16부터 도입된 새로운 재조정(Reconciliation) 알고리즘으로, 각 컴포넌트의 업데이트 과정을 보다 효율적으로 관리하는 역할을 합니다.

`Fiber node`는 각 컴포넌트의 렌더링 상태를 추적하며, 트리 구조로 구성됩니다. 이는 컴포넌트 간의 상호 연결을 유지하며, 각 업데이트 시 빠르고 유연하게 변경 사항을 반영할 수 있게 합니다.

### Fiber와 Node의 역할

1. **Fiber node**: 각 컴포넌트를 표현하는 기본 단위이며, `React Element`의 정보를 포함합니다.

   이를 통해 React는 가상 DOM 트리를 형성하고, 컴포넌트의 상태와 구조를 효과적으로 관리합니다.

2. **Node 역할**: React의 `Virtual DOM` 트리 내에서 컴포넌트 간의 관계와 렌더링 상태를 파악하고,

변경 사항이 발생할 때만 필요한 부분을 업데이트하여 성능을 최적화합니다.

따라서 컴포넌트의 렌더링 과정은 단순히 함수를 호출하는 것을 넘어 Fiber 트리를 구성하고, 이를 바탕으로 가상 DOM과 실제 DOM 간의 변경 사항을 반영하는 구조로 이루어집니다.

요약하면, 컴포넌트 호출이란 다음과 같은 일련의 과정으로 이루어집니다:

- JSX 호출 → Babel 변환 → React Element 생성 → Fiber 생성 → Virtual DOM 업데이트 → 실제 DOM 반영

## 서버 컴포넌트

서버 컴포넌트는 `서버에서 실행`되며 브라우저에서 실행되는 클라이언트 컴포넌트와 다르게 서버에서 렌더링됩니다.

Next.js는 이를 통해 데이터 가져오기와 렌더링 작업을 서버에서 처리하며, 효율적인 데이터 전송을 가능하게 합니다.

Next.js에서는 `Route segment`와 `Suspense boundary`를 기준으로 작업을 청크 단위로 나눠 서버에서 렌더링을 수행합니다.

서버 컴포넌트의 렌더링은 `React Server Component Payload(RSC Payload)`라는 형식으로 데이터를 클라이언트에 전달하여 처리됩니다.

### 서버 컴포넌트 렌더링 단계

Next.js에서 서버 컴포넌트는 클라이언트에서 사용할 수 있는 RSC Payload 형식으로 렌더링됩니다.

이를 통해 초기 로딩 시 서버가 데이터를 전달하고, 이후 클라이언트 측에서 렌더링을 이어갈 수 있습니다.

| 단계                                 | 설명                                                                                                                                                                                            |
| ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1. 서버에서 RSC Payload 생성**     | React는 서버 컴포넌트를 `React Server Component Payload (RSC Payload)`라는 특별한 데이터 포맷으로 렌더링합니다. 서버 컴포넌트는 클라이언트와는 독립적으로 서버에서만 실행됩니다.                |
| **2. RSC Payload 전송 및 HTML 생성** | 서버에서 생성된 RSC Payload는 클라이언트로 전송됩니다. 클라이언트는 이를 이용해 첫 번째 HTML을 미리 생성하여 사용자에게 빠르게 화면을 보여줍니다.                                               |
| **3. 클라이언트 컴포넌트 채우기**    | 클라이언트는 전송된 RSC Payload를 통해 서버 컴포넌트 트리의 빈자리(placeholder)를 찾아 클라이언트 컴포넌트를 채웁니다. 이 과정에서 클라이언트 컴포넌트와 필요한 자바스크립트 파일이 로드됩니다. |
| **4. Hydration (수화)**              | 마지막으로, `hydrate` 과정을 통해 인터랙션을 활성화하여 유저 입력에 반응할 수 있게 합니다. 예를 들어, `useState`의 기본값 외에도 실제 상태 관리와 이벤트 핸들링이 가능해집니다.                 |
| **5. Subsequent CSR 동작**           | 초기 로드 이후에는 클라이언트에서 CSR(Client-Side Rendering)로 동작하여 필요한 부분만 동적으로 업데이트할 수 있습니다.                                                                          |

서버 컴포넌트를 이용한 초기 렌더링은 효율적이며, 이후에는 CSR을 통해 클라이언트에서만 필요한 자원만 업데이트하게 됩니다.

### RSC Payload의 구성 요소

`React Server Component Payload (RSC Payload)`는 서버 컴포넌트가 렌더링된 결과를 클라이언트가 이해하고 적용할 수 있도록 압축된 데이터 포맷입니다.

| 구성 요소                                   | 설명                                                                                                                                                           |
| ------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1. 서버 컴포넌트의 렌더링 결과**          | 서버 컴포넌트가 렌더링된 최종 결과물로, 클라이언트가 DOM을 업데이트할 때 사용하는 핵심 데이터입니다.                                                           |
| **2. 클라이언트 컴포넌트 위치와 파일 참조** | 클라이언트 컴포넌트를 삽입할 자리(placeholder)와 해당 JavaScript 파일의 참조를 포함합니다. 클라이언트 컴포넌트가 서버 컴포넌트 내에 포함될 수 있기 때문입니다. |
| **3. 서버 컴포넌트의 props 정보**           | 서버 컴포넌트가 포함한 모든 props가 전달되어 클라이언트 컴포넌트에서도 동일하게 사용할 수 있습니다.                                                            |

이 구조를 통해 클라이언트는 서버 컴포넌트 트리의 상태를 이해하고, 서버의 결과를 효율적으로 업데이트할 수 있습니다.

### 클라이언트 컴포넌트와 자바스크립트 동작 원리

서버 컴포넌트는 SSR(Server-Side Rendering)에 최적화되어 초기 로딩 속도를 높이고, 클라이언트 컴포넌트는 CSR(Client-Side Rendering) 방식으로 UI 인터랙션을 담당합니다.

이를 통해 복잡한 애플리케이션에서도 성능 최적화와 빠른 로딩을 동시에 달성할 수 있습니다.

| 서버 컴포넌트                                           | 클라이언트 컴포넌트                             |
| ------------------------------------------------------- | ----------------------------------------------- |
| **초기 렌더링** 서버 측에서 수행, 클라이언트로 전달     | **CSR** 이후에는 클라이언트에서만 업데이트 수행 |
| **데이터 페칭 및 렌더링 최적화** - 서버에서 데이터 처리 | **UI 인터랙션** - 상태 관리 및 이벤트 핸들링    |

이를 통해 Next.js는 초기 로드 속도와 복잡한 사용자 인터랙션을 모두 최적화할 수 있는 환경을 제공합니다.

### Next.js 최종 렌더링 과정 요약

Next.js는 서버와 클라이언트 컴포넌트를 조합하여 최적화된 렌더링을 단계별로 수행합니다.

이는 초기 로드 속도와 이후 인터랙션 성능을 최적화할 수 있는 장점이 있습니다.

| 단계                                  | 진행 위치       | 설명                                                                                                                                 |
| ------------------------------------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| **1. 서버 컴포넌트 렌더링 준비**      | 서버            | 서버에서 React 컴포넌트를 렌더링하기 위한 초기 설정을 준비합니다. 이 과정에서 필요한 데이터가 있는 경우 서버 측에서 미리 가져옵니다. |
| **2. 서버 컴포넌트 RSC Payload 생성** | 서버            | React는 서버 컴포넌트를 `React Server Component Payload (RSC Payload)` 형식으로 렌더링하여 최종 HTML 및 데이터를 생성합니다.         |
| **3. RSC Payload 및 HTML 전송**       | 서버→클라이언트 | 서버에서 생성된 RSC Payload와 초기 HTML을 클라이언트로 전송합니다. 클라이언트는 이 HTML을 사용하여 첫 화면을 빠르게 렌더링합니다.    |
| **4. 클라이언트에서 HTML 렌더링**     | 클라이언트      | 클라이언트는 전달받은 HTML을 화면에 즉시 렌더링하여 사용자가 페이지를 빠르게 볼 수 있도록 합니다.                                    |
| **5. 클라이언트 컴포넌트 병합**       | 클라이언트      | 클라이언트는 서버로부터 받은 RSC Payload 내의 placeholder를 찾아 클라이언트 컴포넌트를 결합하여 최종 UI를 완성합니다.                |
| **6. Hydration (수화) 진행**          | 클라이언트      | `Hydration` 과정에서 클라이언트 컴포넌트가 인터랙션을 지원하도록 활성화됩니다. 예를 들어, 이벤트 핸들러나 상태 관리가 가능해집니다.  |
| **7. Subsequent CSR 진행**            | 클라이언트      | 첫 로딩 이후의 내비게이션 및 동적 업데이트는 클라이언트에서만 처리하여 빠른 전환을 제공합니다.                                       |

이러한 단계는 각 컴포넌트의 역할에 따라 클라이언트와 서버 측에서 최적화된 처리를 가능하게 하며, 복잡한 사용자 인터랙션을 포함한 애플리케이션의 성능을 극대화합니다.

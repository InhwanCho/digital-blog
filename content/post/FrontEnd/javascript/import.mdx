---
title: "import vs require"

tags:
  - javascript

description: 'JavaScript에서 "import"와 "require"의 주요 차이점을 설명하고, 각 방식의 사용 사례와 호환성, 문법을 비교 분석합니다.'

date: 2024-08-17
---

## JavaScript 역사

JavaScript는 1995년부터 2009년까지 브라우저에서 동작하기 위한 언어로 주로 프론트엔드에서 사용되었습니다.

하지만 `Node.js`가 등장하면서 JavaScript는 프론트엔드뿐만 아니라 백엔드 개발에서도 사용할 수 있게 되었습니다. Node.js는 JavaScript를 서버 측에서 실행할 수 있는 런타임 환경을 제공하며, 이를 통해 파일 시스템, 모듈 관리, 네트워크 등의 API를 다룰 수 있게 되었습니다.

Node.js의 등장과 함께 백엔드에서 JavaScript의 사용이 확장되었고, 모듈 시스템의 필요성도 부각되었습니다. 이에 따라 두 가지 모듈 시스템인 CommonJS와 ES6 모듈 시스템이 개발되었습니다.

이번 글에서는 `CommonJS`에서 사용되는 `require`와 `ECMAScript 6(ES6)`에서 도입된 `import`를 비교해 설명하겠습니다.

## CommonJS란?

JavaScript는 원래 브라우저에서 동작하기 위한 언어로 설계되었으나, **Node.js**가 등장하면서 서버 측에서도 사용할 수 있게 되었습니다. Node.js 환경에서 모듈을 효율적으로 관리하고 불러오기 위한 표준 방식이 **CommonJS**입니다.

CommonJS는 **모듈**이라는 개념을 도입하여, 각 JavaScript 파일을 독립된 모듈로 취급합니다. 이 모듈들은 서로 격리되어 있어 의존성 충돌을 방지하며, 필요한 경우 다른 모듈을 불러와 사용할 수 있습니다. CommonJS의 가장 큰 특징은 **동기적** 모듈 로딩으로, 모듈이 로드될 때까지 다음 코드의 실행이 중단됩니다. 이러한 방식은 파일 시스템 접근이나 데이터베이스와의 상호작용처럼 서버 측 작업에 적합합니다.

### CommonJS의 주요 특징

| **특징**               | **설명**                                                                      |
| ---------------------- | ----------------------------------------------------------------------------- |
| **모듈 정의**          | 파일 간의 격리 보장, 독립된 모듈로 관리                                       |
| **모듈 불러오기**      | `require()` 함수를 사용하여 동기적으로 모듈을 불러옴                          |
| **모듈 내보내기**      | `module.exports`를 사용하여 특정 기능을 외부로 공개                           |
| **동기적 모듈 로드**   | 모듈 로드가 완료될 때까지 코드 실행이 중단됨                                  |
| **Node.js와의 연관성** | Node.js 환경에서 기본적으로 사용되며, ES6 모듈 시스템 도입 전부터 널리 사용됨 |

### CommonJS의 한계

1. **브라우저 환경에서의 제한**: CommonJS는 브라우저에서 기본적으로 동작하지 않으며, 브라우저에서 사용하려면 Webpack이나 Browserify 같은 번들러가 필요합니다. 이에 따라, 프론트엔드 개발에서는 ES6 모듈 시스템이 더 적합할 수 있습니다.

2. **동기적 로딩의 단점**: CommonJS는 동기적으로 모듈을 로드하기 때문에, 모듈 로드가 완료될 때까지 다른 코드의 실행이 중단됩니다. 서버 환경에서는 큰 문제가 되지 않지만, 네트워크 지연이나 대규모 애플리케이션에서는 성능 문제를 일으킬 수 있습니다.

## import vs require

JavaScript에서는 모듈을 로드하는 두 가지 주요 방식이 존재합니다: `import`와 `require`. 이 둘은 각각 **ECMAScript 6(ES6)** 모듈 시스템과 **CommonJS** 모듈 시스템에 속합니다. 다음 표를 통해 이 두 방식의 차이를 비교해보겠습니다.

| **항목**               | **import**                                               | **require**                                |
| ---------------------- | -------------------------------------------------------- | ------------------------------------------ |
| **모듈 시스템**        | ES6 모듈 (ECMAScript 모듈)                               | CommonJS                                   |
| **사용 환경**          | 주로 프론트엔드 및 최신 Node.js 환경                     | 주로 Node.js (백엔드)                      |
| **동작 방식**          | **정적 로드**: 컴파일 타임에 모듈이 로드됨               | **동적 로드**: 실행 중 모듈을 로드         |
| **호출 방식**          | 모듈 전체 또는 부분을 직접 호출 가능                     | 객체로 호출한 후, 속성으로 접근            |
| **문법**               | `import fs from 'fs';`                                   | `const fs = require('fs');`                |
| **호환성**             | ES6+ 브라우저 및 최신 Node.js                            | Node.js에서만 지원, 브라우저에서 사용 불가 |
| **비동기/동기**        | 비동기적 모듈 로드를 지원 (브라우저 환경)                | 동기적 로드만 지원                         |
| **사용 시기**          | 최신 JavaScript 코드 작성 시 권장됨                      | 주로 레거시 코드나 Node.js에서 사용        |
| **제출 방식**          | 트리 쉐이킹(Tree Shaking)을 통해 불필요한 코드 제거 가능 | 트리 쉐이킹 불가, 전체 모듈 로드           |
| **모듈 내보내기 방식** | `export` 키워드를 사용하여 내보내기 가능                 | `module.exports` 또는 `exports` 사용       |

## 결론

`import`와 `require`는 각각의 용도와 사용 환경에 맞는 장점과 단점이 있습니다.

최신 JavaScript 프로젝트, 특히 프론트엔드와 Node.js의 새로운 기능을 활용하는 프로젝트에서는 `import`를 사용하는 것이 권장됩니다.

반면, 기존의 Node.js 프로젝트나 CommonJS 기반의 레거시 코드에서는 `require`가 여전히 많이 사용되고 있습니다.

모듈 시스템 선택은 프로젝트의 요구 사항과 환경에 따라 달라질 수 있습니다.
